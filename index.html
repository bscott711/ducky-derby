<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ducky Derby Multiplayer</title>
    <style>
        :root {
            --sky-color: #87CEEB;
            --water-color: #1E90FF;
            --water-highlight: #00BFFF;
            --ui-bg: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: var(--sky-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* --- Environment --- */
        .sky {
            flex: 1;
            position: relative;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            overflow: hidden;
        }

        .cloud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            will-change: transform;
        }

        .cloud {
            position: absolute;
            background: white;
            border-radius: 50px;
            opacity: 0.8;
            animation: moveCloud linear infinite;
        }

        @keyframes moveCloud {
            from { transform: translateX(110vw); }
            to { transform: translateX(-200px); }
        }

        .water-container {
            height: 50vh;
            background-color: var(--water-color);
            position: relative;
            overflow: hidden;
            border-top: 5px solid white;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.1);
        }

        #game-world {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%; 
            will-change: transform;
        }

        .wave {
            position: absolute;
            width: 200%;
            height: 100%;
            background-image: radial-gradient(circle at 50% 10px, rgba(255,255,255,0.2) 15px, transparent 16px);
            background-size: 50px 30px;
            animation: waveFlow 4s linear infinite;
            pointer-events: none; 
            will-change: background-position;
        }

        .wave:nth-child(2) {
            top: 10px;
            animation-duration: 7s;
            opacity: 0.5;
            left: -50px;
        }

        @keyframes waveFlow {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50px); }
        }

        /* Finish line is now positioned via JS to match fixed race length */
        .finish-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 10px;
            background: repeating-linear-gradient(45deg, white, white 10px, black 10px, black 20px);
            z-index: 5;
            box-shadow: -2px 0 5px rgba(0,0,0,0.2);
        }

        .finish-flag {
            position: absolute;
            margin-left: -15px;
            top: -30px;
            font-size: 24px;
            z-index: 6;
        }

        /* --- Ducks --- */
        .lane {
            position: absolute;
            left: 0;
            width: 100%; 
            height: 25%; 
            display: flex;
            align-items: center;
            border-bottom: 1px dashed rgba(255,255,255,0.2);
        }

        .duck-wrapper {
            position: absolute;
            left: 10px; 
            width: 80px;
            height: 80px;
            transition: transform 0.1s linear; 
            z-index: 10;
            filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        }

        .duck-name {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0.8;
        }

        #duck-0 .duck-name { top: auto; bottom: -20px; }

        /* --- UI Overlay --- */
        #game-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(2px);
        }

        .panel {
            background: var(--ui-bg);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            max-width: 95%;
            width: 500px;
            border: 4px solid #fff;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 { margin-top: 0; color: #333; font-size: 2rem; }
        h3 { margin: 10px 0; color: #555; }
        p { color: #666; margin-bottom: 1.5rem; }

        .duck-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .bet-btn {
            background: white;
            border: 2px solid #ccc;
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .bet-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .bet-btn.selected {
            border-color: #FFD700;
            background-color: #FFFDE7;
            box-shadow: 0 0 0 3px #FFD700;
        }

        .action-btn {
            background: #FF8C00;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            box-shadow: 0 4px 0 #E67e00;
            margin-top: 20px;
            width: 100%;
        }
        .action-btn:hover { background: #FFA500; }
        .action-btn:disabled { background: #ccc; box-shadow: none; cursor: not-allowed; }

        /* Multiplayer Specific UI */
        .player-list {
            text-align: left;
            background: rgba(0,0,0,0.05);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            max-height: 150px;
            overflow-y: auto;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        .player-item.me { font-weight: bold; color: #1E90FF; }
        
        .input-group { margin-bottom: 15px; }
        input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #ccc;
            width: 70%;
        }

        .room-code-display {
            font-size: 2rem;
            letter-spacing: 5px;
            font-weight: bold;
            color: #333;
            background: #eee;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            user-select: text;
        }

        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            background-color: #f00;
            animation: fall linear forwards;
            z-index: 50;
        }
        @keyframes fall { to { transform: translateY(100vh) rotate(720deg); } }

        /* Podium Styles */
        .podium-container { display: flex; align-items: flex-end; justify-content: center; height: 200px; gap: 10px; margin-top: 20px; }
        .podium-step { display: flex; flex-direction: column; align-items: center; justify-content: flex-end; position: relative; width: 80px; }
        .podium-duck { width: 50px; height: 50px; margin-bottom: 5px; animation: bounce 1s infinite alternate; }
        .podium-bar { width: 100%; border-radius: 8px 8px 0 0; display: flex; justify-content: center; align-items: flex-end; padding-bottom: 10px; color: white; font-weight: bold; font-size: 20px; position: relative; }
        
        .rank-1 .podium-bar { height: 100px; background: #FFD700; order: 2; z-index: 2; }
        .rank-2 .podium-bar { height: 70px; background: #C0C0C0; order: 1; z-index: 1; }
        .rank-3 .podium-bar { height: 50px; background: #CD7F32; order: 3; z-index: 0; }
        .rank-1 { order: 2; } .rank-2 { order: 1; } .rank-3 { order: 3; }

        .podium-names {
            font-size: 10px;
            color: #555;
            text-align: center;
            margin-top: 5px;
            line-height: 1.2;
            font-weight: bold;
            width: 100%;
            white-space: normal;
        }
        
        .user-bet-indicator {
            position: absolute;
            top: -25px;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            z-index: 10;
        }
        .user-bet-indicator::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #333;
        }

    </style>
</head>
<body>

    <div class="sky">
        <div class="cloud-layer" id="cloud-layer">
            <div class="cloud" style="width: 100px; height: 40px; top: 10%; animation-duration: 25s;"></div>
            <div class="cloud" style="width: 140px; height: 50px; top: 25%; animation-duration: 35s; animation-delay: -10s;"></div>
        </div>
    </div>

    <div class="water-container" id="track">
        <div class="wave" id="wave-1"></div>
        <div class="wave" id="wave-2"></div>
        <div id="game-world">
            <!-- Items injected by JS -->
        </div>
    </div>

    <div id="game-ui">
        <!-- SCREEN 1: LOGIN / START -->
        <div class="panel" id="start-panel">
            <h1>ü¶Ü Duck Derby ü¶Ü</h1>
            <p>Enter your name to join the fun!</p>
            <div class="input-group">
                <input type="text" id="player-name-input" placeholder="Your Name (e.g., Maverick)" maxlength="12">
            </div>
            <button class="action-btn" id="create-room-btn">Create New Race</button>
            <br><br>
            <p style="margin-bottom: 5px; font-size: 0.9em;">OR JOIN EXISTING</p>
            <div class="input-group">
                <input type="text" id="room-code-input" placeholder="Enter Room Code" style="text-transform: uppercase;">
            </div>
            <button class="action-btn" id="join-room-btn" style="background: #4CAF50;">Join Race</button>
        </div>

        <!-- SCREEN 2: LOBBY -->
        <div class="panel" id="lobby-panel" style="display: none;">
            <h2 id="room-code-header">ROOM: ????</h2>
            <div class="room-code-display" id="lobby-code-display">????</div>
            
            <h3>Pick Your Duck</h3>
            <div class="duck-grid" id="duck-selection"></div>

            <h3>Racers Ready:</h3>
            <div class="player-list" id="lobby-player-list"></div>

            <p id="host-msg" style="font-size: 0.8em; color: #888; display:none;">You are the host. Click Start when ready.</p>
            <p id="waiting-msg" style="font-size: 0.8em; color: #888;">Waiting for host to start...</p>
            
            <button class="action-btn" id="start-race-btn" disabled style="display:none;">START RACE</button>
        </div>

        <!-- SCREEN 3: RESULTS -->
        <div class="panel" id="results-panel" style="display: none;">
            <h1 id="result-title">Race Finished!</h1>
            <p id="result-message"></p>
            <div class="podium-container" id="podium-display"></div>
            <button class="action-btn" id="back-to-lobby-btn">Back to Lobby</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        // --- CONFIGURATION ---
        // 1. FOR GITHUB PAGES: Replace the 'firebaseConfig' object below with your own from the Firebase Console.
        // 2. Ensure your Firestore Rules allow reads/writes.
        
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBM_L6_YUj4jVplAU7LcGiP0cSwuh24D28",
            authDomain: "ducky-derby.firebaseapp.com",
            projectId: "ducky-derby",
            storageBucket: "ducky-derby.firebasestorage.app",
            messagingSenderId: "898033359128",
            appId: "1:898033359128:web:06a908dace58009689266d",
            measurementId: "G-G50XQ0HY6X"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- APP STATE ---
        let currentUser = null;
        let currentRoomId = null;
        let isHost = false;
        let myDuckIndex = -1;
        let seed = 0; // The magic number for sync
        let raceStatus = 'lobby'; // lobby, racing, finished
        let currentPlayers = {}; // Track all players for results
        
        // --- GAME LOGIC VARS ---
        const DUCK_COLORS = [
            { name: "Sir Quacks", color: "#FFD700", body: "#FFD700", beak: "#FF8C00" }, 
            { name: "Mallard Mike", color: "#00CED1", body: "#48D1CC", beak: "#FFD700" },   
            { name: "Speedy", color: "#FF69B4", body: "#FF69B4", beak: "#FFC0CB" }, 
            { name: "Darkwing", color: "#9370DB", body: "#9370DB", beak: "#4B0082" }         
        ];
        
        // **FIXED RACE LENGTH** // We use a fixed pixel distance so mobile and desktop players see the same race.
        const RACE_DISTANCE = 6000; 

        let ducks = [];
        let finishOrder = [];
        let animationFrameId;
        let cameraX = 0;
        
        // --- DOM ELEMENTS ---
        const startPanel = document.getElementById('start-panel');
        const lobbyPanel = document.getElementById('lobby-panel');
        const resultsPanel = document.getElementById('results-panel');
        const gameWorldEl = document.getElementById('game-world');
        const cloudLayerEl = document.getElementById('cloud-layer');
        const waveEls = document.querySelectorAll('.wave');
        const duckSelectionEl = document.getElementById('duck-selection');
        const playerListEl = document.getElementById('lobby-player-list');
        const startRaceBtn = document.getElementById('start-race-btn');

        // --- AUTH & INIT ---
        async function initAuth() {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                 await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                 await signInAnonymously(auth);
            }
        }
        initAuth();

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                console.log("Logged in:", user.uid);
            }
        });

        // --- DETERMINISTIC RNG ---
        // Mulberry32: A simple seeded random number generator
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        let seededRandom = Math.random; // Default to random until race starts

        // --- FIRESTORE LOGIC ---
        
        const getCollectionPath = () => {
             return typeof __app_id !== 'undefined' 
                ? `artifacts/${__app_id}/public/data/races`
                : 'races'; // For your GitHub pages
        };

        // Create Room
        document.getElementById('create-room-btn').addEventListener('click', async () => {
            const name = document.getElementById('player-name-input').value.trim() || "Player 1";
            if(!currentUser) return;

            // Generate a simple 4-char room code
            const roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
            const raceRef = doc(db, getCollectionPath(), roomId);

            const initialData = {
                hostId: currentUser.uid,
                status: 'lobby',
                seed: 0,
                players: {
                    [currentUser.uid]: { name: name, duckIndex: -1 }
                },
                createdAt: Date.now()
            };

            await setDoc(raceRef, initialData);
            enterLobby(roomId, true, name);
        });

        // Join Room
        document.getElementById('join-room-btn').addEventListener('click', async () => {
            const name = document.getElementById('player-name-input').value.trim() || "Player 2";
            const roomId = document.getElementById('room-code-input').value.trim().toUpperCase();
            if(!roomId || !currentUser) return;

            const raceRef = doc(db, getCollectionPath(), roomId);
            const snap = await getDoc(raceRef);

            if (snap.exists()) {
                // Add self to players
                const currentData = snap.data();
                const players = currentData.players || {};
                players[currentUser.uid] = { name: name, duckIndex: -1 };

                await updateDoc(raceRef, { players: players });
                enterLobby(roomId, false, name);
            } else {
                alert("Room not found!");
            }
        });

        // Enter Lobby & Subscribe
        function enterLobby(roomId, hostStatus, myName) {
            currentRoomId = roomId;
            isHost = hostStatus;
            
            startPanel.style.display = 'none';
            lobbyPanel.style.display = 'block';
            document.getElementById('lobby-code-display').innerText = roomId;
            document.getElementById('room-code-header').innerText = `ROOM: ${roomId}`;

            if(isHost) {
                document.getElementById('host-msg').style.display = 'block';
                startRaceBtn.style.display = 'block';
                document.getElementById('waiting-msg').style.display = 'none';
            }

            // Subscribe to Room Updates
            const raceRef = doc(db, getCollectionPath(), roomId);
            onSnapshot(raceRef, (docSnap) => {
                if(!docSnap.exists()) return;
                const data = docSnap.data();
                
                // UPDATE PLAYERS GLOBALLY
                currentPlayers = data.players || {};
                
                updateLobbyUI(data);
                
                // Check Race Start
                if(data.status === 'racing' && raceStatus === 'lobby') {
                    startClientRace(data.seed);
                }

                // FIX: Listen for "Back to Lobby" signal
                if(data.status === 'lobby' && raceStatus !== 'lobby') {
                    resetToLobby();
                }
            });

            renderDuckSelection();
        }

        // Betting Logic
        async function selectDuck(index) {
            myDuckIndex = index;
            // Update UI immediately for responsiveness
            document.querySelectorAll('.bet-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById(`bet-btn-${index}`).classList.add('selected');

            // Sync to Firestore
            const raceRef = doc(db, getCollectionPath(), currentRoomId);
            const snap = await getDoc(raceRef);
            if(snap.exists()) {
                const players = snap.data().players;
                players[currentUser.uid].duckIndex = index;
                await updateDoc(raceRef, { players: players });
            }
        }

        // Host Starts Race
        startRaceBtn.addEventListener('click', async () => {
            if(!isHost) return;
            const seedVal = Math.floor(Math.random() * 1000000); // Generate seed
            const raceRef = doc(db, getCollectionPath(), currentRoomId);
            await updateDoc(raceRef, {
                status: 'racing',
                seed: seedVal
            });
        });

        function updateLobbyUI(data) {
            playerListEl.innerHTML = '';
            const players = data.players || {};
            let readyCount = 0;
            let totalCount = 0;

            Object.entries(players).forEach(([uid, p]) => {
                totalCount++;
                const div = document.createElement('div');
                div.className = 'player-item' + (uid === currentUser.uid ? ' me' : '');
                
                let duckName = "Selecting...";
                if(p.duckIndex !== -1) {
                    duckName = DUCK_COLORS[p.duckIndex].name;
                    readyCount++;
                }
                
                div.innerHTML = `<span>${p.name}</span> <span>${duckName}</span>`;
                playerListEl.appendChild(div);
            });

            // Enable start button if host and everyone is ready
            if(isHost) {
                startRaceBtn.disabled = (readyCount === 0);
            }
        }

        // --- GAME ENGINE ---

        function startClientRace(seedVal) {
            raceStatus = 'racing';
            seed = seedVal;
            seededRandom = mulberry32(seed); // LOCK IN THE SEED
            cameraX = 0; // Reset camera specifically for new race
            
            // FIX: Hide the entire UI container so the blur effect goes away
            document.getElementById('game-ui').style.display = 'none';
            lobbyPanel.style.display = 'none';
            
            initGameWorld();
            requestAnimationFrame(gameLoop);
        }

        // NEW: Function to reset everyone to the lobby without reloading page
        function resetToLobby() {
             raceStatus = 'lobby';
             finishOrder = [];
             ducks = [];
             
             // UI Switching
             resultsPanel.style.display = 'none';
             lobbyPanel.style.display = 'block';
             document.getElementById('game-ui').style.display = 'flex'; // Bring back overlay
             
             // Reset World
             gameWorldEl.innerHTML = ''; 
             gameWorldEl.style.transform = 'translateX(0px)';
             cameraX = 0;
             
             // Reset Parallax
             waveEls.forEach(wave => { wave.style.backgroundPositionX = `0px`; });
             if(cloudLayerEl) { cloudLayerEl.style.transform = `translateX(0px)`; }

             // Re-render ducks in lobby
             renderDuckSelection();
        }

        function getDuckSVG(colorConfig) {
             return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g transform="scale(-1, 1) translate(-100, 0)"><path d="M20,60 Q20,90 50,90 L75,90 Q95,90 95,70 Q95,50 75,50 L70,50 L70,40 Q70,10 45,10 Q20,10 20,40 L20,60 Z" fill="${colorConfig.body}" stroke="#333" stroke-width="2"/><path d="M40,65 Q50,85 70,65" fill="none" stroke="${colorConfig.beak}" stroke-width="3" stroke-linecap="round" /><circle cx="40" cy="30" r="5" fill="white" /><circle cx="42" cy="30" r="2" fill="black" /><path d="M20,35 Q5,35 5,45 Q5,50 20,45 Z" fill="${colorConfig.beak}" stroke="#333" stroke-width="1"/></g></svg>`;
        }

        function renderDuckSelection() {
            duckSelectionEl.innerHTML = '';
            DUCK_COLORS.forEach((duckConfig, index) => {
                const btn = document.createElement('div');
                btn.className = 'bet-btn';
                btn.id = `bet-btn-${index}`;
                btn.innerHTML = `${getDuckSVG(duckConfig)}<strong>${duckConfig.name}</strong>`;
                btn.onclick = () => selectDuck(index);
                duckSelectionEl.appendChild(btn);
            });
        }

        function initGameWorld() {
            // Reconstruct Game World with Fixed Finish Line Position
            gameWorldEl.innerHTML = `
                <div class="finish-line" style="left: ${RACE_DISTANCE}px;"></div>
                <div class="finish-flag" style="left: ${RACE_DISTANCE}px; top: 20%">üèÅ</div>
                <div class="finish-flag" style="left: ${RACE_DISTANCE}px; top: 45%">üèÅ</div>
                <div class="finish-flag" style="left: ${RACE_DISTANCE}px; top: 70%">üèÅ</div>
                <div class="finish-flag" style="left: ${RACE_DISTANCE}px; top: 95%">üèÅ</div>
            `; 
            
            ducks = [];
            finishOrder = [];
            
            DUCK_COLORS.forEach((duckConfig, index) => {
                const lane = document.createElement('div');
                lane.className = 'lane';
                lane.style.top = `${index * 25}%`;
                
                const duckDiv = document.createElement('div');
                duckDiv.className = 'duck-wrapper';
                duckDiv.id = `duck-${index}`;
                duckDiv.innerHTML = `${getDuckSVG(duckConfig)}<div class="duck-name">${duckConfig.name}</div>`;
                
                lane.appendChild(duckDiv);
                gameWorldEl.appendChild(lane);

                ducks.push({
                    el: duckDiv,
                    originalIndex: index,
                    x: 0,
                    speed: 2,
                    wobbleOffset: seededRandom() * Math.PI * 2, // Use seeded random
                    finished: false,
                    config: duckConfig
                });
            });
            
            // Initial render
            gameWorldEl.style.transform = `translateX(0px)`;
        }

        function gameLoop(timestamp) {
            if (raceStatus !== 'racing' && finishOrder.length === ducks.length) return;

            const finishLineX = RACE_DISTANCE;
            // Stop camera scrolling earlier so we can see the finish line centered better
            const maxCameraX = finishLineX - (window.innerWidth * 0.8);
            
            let leadingDuckX = 0;

            ducks.forEach((duck) => {
                if (duck.finished) {
                    if(duck.x > leadingDuckX) leadingDuckX = duck.x;
                    return; 
                }

                // Deterministic Momentum
                duck.speed += (seededRandom() - 0.5) * 0.1;
                duck.speed = Math.max(2, Math.min(duck.speed, 6));

                duck.x += duck.speed;
                if(duck.x > leadingDuckX) leadingDuckX = duck.x;

                const wobbleY = Math.sin((timestamp / 200) + duck.wobbleOffset) * 5;
                duck.el.style.transform = `translate(${duck.x}px, ${wobbleY}px)`;

                if (duck.x >= finishLineX) {
                    duck.finished = true;
                    duck.x = finishLineX + (seededRandom() * 50);
                    finishOrder.push(duck);
                    
                    if (finishOrder.length === ducks.length) {
                        endRace();
                    }
                }
            });

            // Camera Smoothing
            let targetCameraX = Math.max(0, leadingDuckX - (window.innerWidth * 0.4));
            if (targetCameraX > maxCameraX) targetCameraX = maxCameraX;
            
            // Slightly tighter tracking (0.1 instead of 0.05) to fix "focus off" feeling
            cameraX += (targetCameraX - cameraX) * 0.1;

            gameWorldEl.style.transform = `translateX(-${cameraX}px)`;
            
            waveEls.forEach(wave => { wave.style.backgroundPositionX = `-${cameraX}px`; });
            if(cloudLayerEl) { cloudLayerEl.style.transform = `translateX(-${cameraX * 0.1}px)`; }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endRace() {
            raceStatus = 'finished';
            cancelAnimationFrame(animationFrameId);
            setTimeout(() => {
                // FIX: Bring back the UI container for results
                document.getElementById('game-ui').style.display = 'flex';
                resultsPanel.style.display = 'block';
                const podiumDisplay = document.getElementById('podium-display');
                podiumDisplay.innerHTML = '';

                // Identify Winners
                const winningDuckIndex = finishOrder[0].originalIndex;
                const winners = Object.values(currentPlayers).filter(p => p.duckIndex === winningDuckIndex);
                const winnerNames = winners.map(p => p.name);
                const userWon = (myDuckIndex === winningDuckIndex);
                
                const resultTitle = document.getElementById('result-title');
                const resultMessage = document.getElementById('result-message');

                // Dynamic Message
                if (userWon) {
                    resultTitle.textContent = "You Won! üéâ";
                    resultTitle.style.color = "#2ecc71";
                    
                    const otherWinners = winnerNames.filter(n => n !== currentPlayers[currentUser.uid].name);
                    if(otherWinners.length > 0) {
                        resultMessage.textContent = `(Shared with ${otherWinners.join(', ')})`;
                    } else {
                        resultMessage.textContent = "Your duck is the champion!";
                    }
                    createConfetti();
                } else {
                    if (winnerNames.length > 0) {
                        resultTitle.textContent = `${winnerNames.join(' & ')} Won!`;
                        resultTitle.style.color = "#333";
                        resultMessage.textContent = `They picked ${DUCK_COLORS[winningDuckIndex].name}.`;
                    } else {
                        resultTitle.textContent = "No Winners!";
                        resultTitle.style.color = "#e74c3c";
                        resultMessage.textContent = "No one picked the winner.";
                    }
                }

                // Build Podium
                for(let i = 0; i < 3; i++) {
                    if (i >= finishOrder.length) break;
                    const duck = finishOrder[i];
                    const rank = i + 1;
                    
                    // Find who picked this duck
                    const pickers = Object.values(currentPlayers)
                        .filter(p => p.duckIndex === duck.originalIndex)
                        .map(p => p.name);

                    const step = document.createElement('div');
                    step.className = `podium-step rank-${rank}`;
                    
                    // "You" indicator
                    const isMyPick = (duck.originalIndex === myDuckIndex);
                    const meIndicator = isMyPick ? `<div class="user-bet-indicator">You</div>` : '';

                    step.innerHTML = `
                        ${meIndicator}
                        <div class="podium-duck">${getDuckSVG(duck.config)}</div>
                        <div class="podium-bar">${rank}</div>
                        <div class="podium-names">${pickers.join('<br>')}</div>
                    `;
                    podiumDisplay.appendChild(step);
                }

                // Show appropriate button text based on role
                const backBtn = document.getElementById('back-to-lobby-btn');
                if(isHost) {
                    backBtn.textContent = "Back to Lobby (Host)";
                    backBtn.disabled = false;
                    backBtn.style.opacity = "1";
                } else {
                    backBtn.textContent = "Waiting for Host...";
                    backBtn.disabled = true;
                    backBtn.style.opacity = "0.7";
                }

            }, 1000);
        }

        // FIX: Update button to sync with Database instead of window.reload()
        document.getElementById('back-to-lobby-btn').onclick = async () => {
            if (isHost) {
                const raceRef = doc(db, getCollectionPath(), currentRoomId);
                // This updates DB -> Listener fires -> calls resetToLobby() for everyone
                await updateDoc(raceRef, { status: 'lobby' });
            }
        };

        function createConfetti() {
            const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
            for (let i = 0; i < 50; i++) {
                const conf = document.createElement('div');
                conf.className = 'confetti';
                conf.style.left = Math.random() * 100 + 'vw';
                conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                conf.style.animationDuration = (Math.random() * 2 + 2) + 's';
                document.body.appendChild(conf);
            }
        }
    </script>
</body>
</html>